Pour obtenir la version du noyau :
k get nodes/mcordess -o json | jq '.status.nodeInfo.kernelVersion'

------------------------------------------------------------------------------------------

Tu dois configurer un cluster K3s en **mode serveur** avec 1 VM, faire tourner **3 applications web** (app1, app2, app3), et exposer ces applications **selon l'en-tÃªte HTTP `Host`** utilisÃ© dans la requÃªte. Voici une solution Ã©tape par Ã©tape :

---

## ğŸ¯ Objectif

* **1 VM K3s (nommÃ©e `tonloginS`)**
* **3 applis web accessibles selon l'en-tÃªte `Host` :**

  * `app1.com` âŸ¶ affiche app1
  * `app2.com` âŸ¶ affiche app2 (avec 3 **rÃ©plicas**)
  * tout autre nom de domaine ou vide âŸ¶ affiche app3 (valeur par dÃ©faut)
* L'adresse IP de la VM est `192.168.56.110`

---

## ğŸ§± Ã‰tapes dÃ©taillÃ©es

---

### 1. ğŸ–¥ï¸ CrÃ©er et configurer la VM

Assure-toi dâ€™avoir une VM avec :

* Ubuntu 22.04 ou Debian (ou autre stable)
* IP fixe : `192.168.56.110`
* Nom de la VM : `tonloginS` (ex: `jessS`)

Modifie le rÃ©seau dans le `Vagrantfile` :

```ruby
config.vm.network "private_network", ip: "192.168.56.110"
```

---

### 2. ğŸ“¦ Installer K3s (mode serveur)

Sur la VM :

```bash
curl -sfL https://get.k3s.io | sh -
```

VÃ©rifie que tout fonctionne :

```bash
sudo kubectl get nodes
```

---

### 3. ğŸŒ CrÃ©er un Ingress Controller

Par dÃ©faut, K3s installe **Traefik** comme ingress controller. On lâ€™utilisera ici.

Tu peux vÃ©rifier avec :

```bash
sudo kubectl get pods -A | grep traefik
```

---

### 4. ğŸ› ï¸ DÃ©ployer les applications

Tu vas crÃ©er 3 **Deployment** + 3 **Services** + 1 **Ingress**

#### a. App1 (1 rÃ©plique)

```yaml
# app1.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: app1
  template:
    metadata:
      labels:
        app: app1
    spec:
      containers:
      - name: app1
        image: nginx
        env:
        - name: APP
          value: app1
---
apiVersion: v1
kind: Service
metadata:
  name: app1
spec:
  selector:
    app: app1
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

#### b. App2 (3 rÃ©plicas)

```yaml
# app2.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app2
spec:
  replicas: 3
  selector:
    matchLabels:
      app: app2
  template:
    metadata:
      labels:
        app: app2
    spec:
      containers:
      - name: app2
        image: nginx
        env:
        - name: APP
          value: app2
---
apiVersion: v1
kind: Service
metadata:
  name: app2
spec:
  selector:
    app: app2
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

#### c. App3 (dÃ©faut)

```yaml
# app3.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app3
spec:
  replicas: 1
  selector:
    matchLabels:
      app: app3
  template:
    metadata:
      labels:
        app: app3
    spec:
      containers:
      - name: app3
        image: nginx
        env:
        - name: APP
          value: app3
---
apiVersion: v1
kind: Service
metadata:
  name: app3
spec:
  selector:
    app: app3
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

---

### 5. ğŸŒ CrÃ©er une Ingress

```yaml
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: apps-ingress
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: web
spec:
  rules:
  - host: app1.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app1
            port:
              number: 80
  - host: app2.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app2
            port:
              number: 80
  - host: "*"
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app3
            port:
              number: 80
```

---

### 6. ğŸš€ Appliquer les fichiers

```bash
kubectl apply -f app1.yaml
kubectl apply -f app2.yaml
kubectl apply -f app3.yaml
kubectl apply -f ingress.yaml
```

---

### 7. ğŸ§ª Tester

Sur ta machine hÃ´te, ajoute les entrÃ©es dans `/etc/hosts` :

```
192.168.56.110 app1.com
192.168.56.110 app2.com
```

Puis ouvre dans un navigateur :

* [http://app1.com](http://app1.com) âŸ¶ affiche app1
* [http://app2.com](http://app2.com) âŸ¶ affiche app2 (load balancÃ© sur 3 pods)
* [http://192.168.56.110](http://192.168.56.110) ou un autre host âŸ¶ affiche app3

---

### âœ… Bonus : Personnaliser les pages (facultatif)

Pour voir la diffÃ©rence entre les applis, tu peux crÃ©er une image Docker personnalisÃ©e avec une page HTML diffÃ©rente ou utiliser une config `nginx.conf`.


--------------------------------------------------------------------------------


C'est quoi un ingress

Bonne question ! Un **Ingress** dans Kubernetes (et donc aussi dans **K3s**) est une **ressource qui gÃ¨re l'accÃ¨s externe** Ã  tes applications **HTTP/HTTPS**, gÃ©nÃ©ralement via un **nom de domaine (host)** ou un **chemin URL**.

---

## ğŸ” DÃ©finition simple

ğŸ‘‰ **Ingress = une porte dâ€™entrÃ©e HTTP dans ton cluster**

Il agit comme un **routeur** HTTP : il reÃ§oit les requÃªtes venant de l'extÃ©rieur (navigateur, API...), puis les **redirige vers le bon service** (pod) dans ton cluster, selon des rÃ¨gles que tu dÃ©finis.

---

## ğŸ“¦ Exemples concrets

Imaginons que tu as 3 services dans ton cluster :

* `app1` â†’ page d'accueil
* `app2` â†’ API
* `app3` â†’ admin

Tu veux que :

* `http://app1.com` aille vers app1
* `http://app2.com` aille vers app2
* `http://app3.com/admin` aille vers app3

Au lieu dâ€™exposer chaque service avec un **NodePort** ou un **LoadBalancer**, tu crÃ©es **un seul point dâ€™entrÃ©e** avec un **Ingress**, et tu le configures pour router chaque requÃªte.

---

## ğŸ§­ Fonctionnement schÃ©matique

```
Navigateur --> [Ingress Controller] --> Service --> Pods
               (Traefik/Nginx)
```

---

## ğŸ› ï¸ Ingress vs Ingress Controller

Il y a 2 composants :

1. **Ingress** (objet YAML) â†’ les rÃ¨gles
2. **Ingress Controller** â†’ l'outil qui applique ces rÃ¨gles (ex: **Traefik** dans K3s)

ğŸ’¡ Dans K3s, **Traefik est dÃ©jÃ  intÃ©grÃ© par dÃ©faut** comme Ingress Controller.

---

## ğŸ“‹ Exemple de rÃ¨gle Ingress

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: mon-ingress
spec:
  rules:
  - host: app1.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app1
            port:
              number: 80
```

ğŸ‘‰ Cette rÃ¨gle dit : â€œsi une requÃªte HTTP arrive avec le host `app1.com`, alors envoie-la au **service `app1`** sur le port 80â€.

---

## âœ… En rÃ©sumÃ©

| Terme                  | RÃ´le                                                                       |
| ---------------------- | -------------------------------------------------------------------------- |
| **Ingress**            | Fichier YAML qui dÃ©crit les routes HTTP                                    |
| **Ingress Controller** | Application qui lit ces fichiers et fait le routage (Traefik, Nginx, etc.) |
| **Service**            | Fait le lien entre l'Ingress et les Pods                                   |
| **Pod**                | Contient ton application                                                   |

---

### ğŸ“¦ Architecture du routage HTTP avec Ingress

```
                  ğŸ§‘ Utilisateur (navigateur)
                            |
                            â–¼
               ğŸŒ RequÃªte HTTP (ex: app1.com)
                            |
                            â–¼
                 ğŸšª Ingress Controller (Traefik)
                            |
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        |                   |                    |
        â–¼                   â–¼                    â–¼
    ğŸ“¦ Service app1     ğŸ“¦ Service app2       ğŸ“¦ Service app3
        |                   |                    |
        â–¼                   â–¼                    â–¼
   ğŸ³ Pod app1          ğŸ³ Pod app2 x3       ğŸ³ Pod app3
```

---

### ğŸ§  Ce qui se passe concrÃ¨tement

1. **Lâ€™utilisateur** tape `http://app1.com` dans son navigateur.
2. La requÃªte arrive Ã  lâ€™IP du cluster (ta VM `192.168.56.110`).
3. Le **Traefik Ingress Controller** reÃ§oit la requÃªte.
4. Il lit les rÃ¨gles dÃ©finies dans lâ€™**Ingress** :

   * Si `Host == app1.com` â†’ route vers `service app1`
   * Si `Host == app2.com` â†’ route vers `service app2` (3 rÃ©plicas)
   * Sinon â†’ `service app3` (valeur par dÃ©faut)
5. Le **service** sÃ©lectionne un **pod** et transmet la requÃªte.
6. Le **pod** rÃ©pond (ex : `nginx`, `Hello from app2`, etc.)

---

### ğŸ“ Ce quâ€™il te faut pour que Ã§a marche :

* Les fichiers YAML `Deployment` + `Service` + `Ingress`
* Un **Ingress Controller** (Traefik est dÃ©jÃ  lÃ  dans K3s)
* Ton `/etc/hosts` bien configurÃ© avec :

```txt
192.168.56.110 app1.com
192.168.56.110 app2.com
```
